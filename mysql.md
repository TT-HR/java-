Mysql的默认存储引擎

- Mysql的默认存储引擎为InnoDB，并且在5.7版本中所有的存储引擎只有InnoDB是事务性存储引擎，等于说只有InnoDB支持事务。

mysql5.5之前的默认存储引擎是MyISAM引擎

- MyISAM虽然性能极佳，而且具备大量特性，全文索引、压缩、空间函数等，但MyISAM不支持事务和行级锁，而且最大的缺陷就是崩溃后无法安全恢复，不过，5.5版本之后，mysql就引入了InnoDB(事务性数据库引擎)，mysql5.5版本后默认的存储引擎都是InnoDB。

两者的区别(MyISAM和InnoDB)

- 是否支持行级锁：MyISAM只有表级锁，而InnoDB有表级锁和行级锁，默认为行级锁。

- 是否支持事务和崩溃后的安全恢复：MyISAM强调的是性能，每次查询具有原子性，其执行速度比InnoDB速度更快，但是不提供事务支持。但是InnoDB支持事务，外部键等高级数据库功能，具有事务，回滚、和崩溃修复能力的事务安全型表。

- 是否支持外键：MyISAM不支持，InnoDB支持

- 是否支持MVCC：只有InnoDB支持，应对高并发事务，MVCC比单纯的加锁更高效。MVCC比单纯的加锁更高效;MVCC只在 `READ COMMITTED`(读取已提交) 和 `REPEATABLE READ`(可重复读) 两个隔离级别下工作;MVCC可以使用 乐观(optimistic)锁 和 悲观(pessimistic)锁来实现;各数据库中MVCC实现并不统一。(不太清楚)

  ###### **《MySql高性能》上面有一句话这样写到：**

  > 不要轻易相信“MyISAM比InnoDB快”之类的经验之谈，这个结论往往不是绝对的。在很多我们已知场景中，InnoDB的速度都可以让MyISAM望尘莫及，尤其是用到了聚簇索引，或者需要访问的数据都可以放入内存的应用。

索引：

Mysql使用的索引结构主要有BTree索引和哈希索引。哈希索引底层的数据结构就是哈希表，所以在绝大多数需求为单条记录查询的时候，选择哈希索引，查询性能最快。其余的大部分场景，建议使用BTree索引。

Mysql的BTree索引使用的是B树中的B+Tree，在主要的两大数据库存储引擎中实现方式不同。

- MyISAM：B+Tree叶节点data域放的是数据记录的地址。在索引检索的时候，首先按照B+Tree搜索算法搜索索引，如果指定的key存在，则去除其data的域，然后以data域的值为地址，读取相应的数据记录。这被称为“非聚簇索引”。**简单来说，即B+Tree节点的data域并没有直接存放数据，而是存放了数据记录的地址，索引搜索到指定的key后再根据data域中存放的地址去读取相应的数据记录**
- InnoDB：其数据文件本身就是索引文件，树的叶节点data域存放了完整的数据记录，整个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引，这被称为“聚簇索引”。而其余的索引都作为辅助 索引，辅助索引的data域存放的是相应记录主键的值而不是地址，**在使用主索引搜索时，根据key即可直接找到数据，而在使用辅助索引时，根据key可以得到主键的值，而后根据主键的值走主索引查询**。

查询缓存：

> 执行查询语句的时候，会先查询缓存。在Mysql8.0之后被移除，因为这个功能不太实用。

**开启查询缓存后，在相同的查询条件以及数据情况下，会直接在缓存中命中结果**，但很多条件都会导致缓存失效，并且诸多条件例如：客户端协议版本号，数据库，临时表、用户变量、自定义函数等等都会导致缓存不命中。

**缓存虽然增加了数据库的查询性能，但是缓存也带来了额外的性能开销，每次查询后都需要做一次缓存操作，失效后还需要销毁**。一般来说，设置缓存的大小为几十MB比较合适。

事务：

- ###### 什么是事务

  - 事务就是逻辑上的一组操作，要么全部执行成功，要么都不执行，即A函数存在1、2、3，三个操作数据库的指令，当执行操作在1、2、3任意一部执行失败后，三个操作数据库的指令都会被撤销，只有当三个指令全部执行成功，A函数才能完成执行。

- 事务的四大特性：ACID

  - A：**原子性**：事务是最小的执行单位，不允许分割，事务里的原子性确保动作要么全部执行成功，要么全部不起作用
  - C：**一致性**：执行事务后，数据库从一个正确的状态变更到另一个正确的状态
  - I：**隔离性**：并发访问数据库时，一个用户的事务不被其他事务所干扰，并发事物之间的数据库是独立的。
  - D：**持久性**：一个事务被提交后，对数据库造成的改变是持久的，即使数据库故障也不会发生改变

- ###### 并发事务带来的问题

  - **脏读**：当一个事务正在访问数据并且对数据进行修改时，另一个事务访问到了这个数据，并且使用了这个数据，但因为该数据还未被提交，所以另外一个事务读取到的数据是脏数据。
  - **修改丢失**：指一个事务读取一个数据时，另一个事务也访问了该数据，如果第一个事务修改了这个数据，第二个事务也同样修改了数据，第一个事务修改的数据结果就会丢失，这种情况被称为修改丢失
  - **不可重复读**：指在第一个事务内多次读取同一个数据，在这个事务还未结束时另一个事务也访问该数据。那么第一个事务在多次读取事务是，由于另一个事务对该数据进行了修改，可能会出现第一个事务前后两次读取统一数据结果不同的情况。
  - **幻读**：与不可重复读类似，区别在于，第一个事务在读取过程中因为第二个事务插入了一些数据，所以第一个事务多了一些原本不存在的数据记录，就像发生了幻觉一样。所以叫幻读。

事物的隔离级别有哪些？mysql的默认事务隔离级别是？

- SQL标准定义了四个隔离级别：

  - **READ-UNCOMMITTED(读取未提交)**：最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读、不可重复读。
  - **READ-COMMITTED(读取已提交)**：允许读取并发事务已经提交的数据，可以阻止脏读，但幻读或者不可重复读仍然会发生。
  - **REPEATABLE-READ(可重复读)**：对同一字段的多次读取结果都是一致的，可以阻止脏读和不可重复读，但仍会出现幻读。
  - **SERIALIAZABLE(可串行化)**：最高的隔离级别，完全服从ACID的隔离级别，可以防止所有事务并发出现的问题。

- Mysql的默认隔离级别为**可重复读**，但需要注意的是，InnoDB存储引擎在**可重复读**事务隔离级别下使用的是Next-key lock锁算法(不懂)，所以可以避免幻读的出现，所以虽然mysql的默认事务隔离级别是**可重复读**但其实InnoDB的隔离级别已经完全保证了事物的隔离要求，即达到了**可串行化**

  InnoDB存储引擎在分布式事务的情况下一般会用的**可串行化**的隔离级别

Mysql两种主要存储引擎使用的锁，MyISAM和InnoDB

- MyISAM使用表级锁
- InnoDB支持表级锁和行级锁，默认使用行级锁

表级锁和行级锁对别：

- 表级锁：Mysql中粒度最大的一种锁，对当前操作的整张表加锁，实现简单，资源消耗也比较少，加锁快，不会出现死锁，但出发锁冲突的概率最高，并发度最低
- 行级锁：Mysql中粒度最小的一种锁，只针对当前操作的行加锁，能够减少数据库操作的冲突，并发度最高，但锁的性能开销较大，加锁慢，会出现死锁。

大表优化：

​		当Mysql单表记录过大，数据库的CURD性能会明显下降，常见的优化措施如下：

1. 限定数据的查询范围：禁止不带任何限制数据查询限制的语句
2. 读写分离：数据库拆分，主库负责写，从库负责读
3. 垂直分区：即将一张表中的表列，即字段，拆分为多个表。
   优点：可以使数据列变小，减少I/O次数，简化表结构，便于维护。
   缺点：主键出现冗余，查询需要使用join，并且事务管理会变得复杂。
4. 水平分区：表结构不变，但是表数据通过某种策略存储数据分片，将每一片数据分散到不同的表或者库中，达到了分布式的目的，可以支撑非常大的数据量。
   优点：支持非常大的数据量，应用端改造少。
   缺点：部署、逻辑和运维会带来更高的复杂度。
   两种常见的数据库分片方式：
   1. 客户端代理
   2. 中间件代理

解释一下什么是池化思想。什么是数据库连接池，为什么要用到数据库连接池？

- 池化思想很多地方都能够看到，例如java的线程池、jdbc的连接池、redis的连接池，可以将连接池看作是连接操作的缓存，使用是可以直接从池中取出，优化连接造成的资源开销，提升连接速度。
- 数据库连接池本质上是socket链接，使用数据库连接池创建连接后放置在池中，并再次使用它，不用每次使用都建立新的连接，连接池还减少了用户必须等待建立与数据库的连接时间。
